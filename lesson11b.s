;
; File generated by cc65 v 2.16 - Git cdca644
;
	.fopt		compiler,"cc65 v 2.16 - Git cdca644"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_NMI_flag
	.export		_Frame_Count
	.export		_index
	.export		_index2
	.export		_index3
	.export		_index4
	.export		_lives
	.export		_X1
	.export		_Y1
	.export		_state
	.export		_state4
	.export		_joypad1
	.export		_joypad1old
	.export		_joypad1test
	.export		_joypad2
	.export		_joypad2old
	.export		_joypad2test
	.export		_Room
	.export		_RoomB
	.export		_RoomPlus
	.export		_Room_Address
	.export		_Horiz_scroll
	.export		_Horiz_scroll_Old
	.export		_Horiz_scroll_Plus
	.export		_Scroll_Adjusted_X
	.export		_Game_Mode
	.export		_Nametable
	.export		_NametableB
	.export		_Nametable_Plus
	.export		_walk_count
	.export		_X_speed
	.export		_Y_speed
	.export		_direction
	.export		_collision_Index
	.export		_high_byte
	.export		_collision
	.export		_collisionBot
	.export		_collisionOld
	.export		_temp
	.export		_temp2
	.export		_temp3
	.export		_temp4
	.export		_PPU_ADDRESS_High
	.export		_PPU_ADDRESS_Low
	.export		_A
	.export		_PPU_flag
	.export		_PPU_flag2
	.export		_dummy
	.export		_SPRITE_ZERO
	.export		_SPRITES
	.export		_C_MAP
	.export		_C_MAP2
	.export		_BUFFER1
	.export		_BUFFER2
	.export		_BUFFER3
	.export		_BUFFER4
	.export		_BUFFER5
	.export		_BUFFER6
	.export		_BUFFER7
	.export		_L1
	.export		_L2
	.export		_L3
	.export		_L4
	.export		_Title
	.export		_death
	.export		_ROOMS
	.export		_PLATFORM
	.export		_METATILES
	.export		_MT_color
	.export		_HUD
	.export		_PALETTE
	.export		_Walk_Moves
	.export		_MetaSprite_Y
	.export		_MetaSprite_Tile_Right
	.export		_MetaSprite_Attrib_Right
	.export		_MetaSprite_X
	.export		_MetaSprite_Tile_Left
	.export		_MetaSprite_Attrib_Left
	.export		_All_Off
	.export		_All_On
	.export		_Reset_Scroll
	.export		_Load_Palette
	.export		_update_Sprites
	.export		_Collision_Down
	.export		_move_logic
	.export		_Do_Buffer
	.export		_Do_Buffer2
	.export		_Do_Buffer3
	.export		_Draw_Title
	.export		_Draw_Death
	.export		_Draw_Background
	.export		_Set_Sprite_Zero
	.export		_Load_HUD
	.export		_Should_We_Buffer
	.export		_New_Room
	.import		_memcpy
	.import		_UnRLE
	.import		_Wait_Vblank
	.import		_Get_Input
	.import		_Sprite_Zero
	.import		_Super_Fast_Write_PPU
	.import		_Super_Fast_Write_PPU2
	.export		_Buffer_Tiles
	.export		_Buffer_Tiles2
	.export		_currentNote
	.export		_currentTick
	.export		_currentBar
	.export		_currentBeat
	.export		_currentSemiQ
	.export		_currentState
	.export		_notes
	.export		_bossaBassA
	.export		_bossaBassB
	.export		_bossaBassPos
	.export		_setupAudio
	.export		_audioUpdate
	.export		_audioBeep
	.export		_playSquare
	.export		_playTri
	.export		_playNoise
	.export		_sneezeSound
	.export		_bossaSong
	.export		_songTest
	.export		_bassLine
	.export		_bassNote
	.export		_main

.segment	"DATA"

_currentNote:
	.byte	$00
_currentTick:
	.byte	$00
_currentBar:
	.byte	$00
_currentBeat:
	.byte	$00
_currentSemiQ:
	.byte	$00
_currentState:
	.byte	$00
_notes:
	.byte	$E0
	.byte	$A0
	.byte	$80
	.byte	$3E
	.byte	$0C
	.byte	$E3
	.byte	$B3
	.byte	$92
	.byte	$6F
	.byte	$4C
	.byte	$29
	.byte	$0A
	.byte	$EE
	.byte	$D2
	.byte	$B7
	.byte	$9F
	.byte	$88
	.byte	$70
	.byte	$5B
	.byte	$48
	.byte	$36
	.byte	$24
	.byte	$14
	.byte	$05
	.byte	$F6
	.byte	$E8
	.byte	$DB
	.byte	$CF
	.byte	$C3
	.byte	$B8
	.byte	$AF
	.byte	$A4
	.byte	$9B
	.byte	$92
	.byte	$8B
_bossaBassA:
	.byte	$09
	.byte	$00
	.byte	$10
	.byte	$03
	.byte	$10
	.byte	$04
	.byte	$09
	.byte	$07
	.byte	$09
	.byte	$08
	.byte	$10
	.byte	$0B
	.byte	$10
	.byte	$0C
	.byte	$09
	.byte	$0E
_bossaBassB:
	.byte	$07
	.byte	$00
	.byte	$0E
	.byte	$03
	.byte	$0E
	.byte	$04
	.byte	$07
	.byte	$07
	.byte	$06
	.byte	$08
	.byte	$0D
	.byte	$0B
	.byte	$09
	.byte	$0C
	.byte	$10
	.byte	$0F
_bossaBassPos:
	.byte	$00
_bassLine:
	.byte	$06
	.byte	$01
	.byte	$06
	.byte	$01
_bassNote:
	.byte	$00

.segment	"RODATA"

_L1:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$1A
	.byte	$1A
	.byte	$1B
	.byte	$1C
	.byte	$1D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$12
	.byte	$05
	.byte	$05
	.byte	$06
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$19
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$16
	.byte	$0E
	.byte	$0E
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$14
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$15
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$11
	.byte	$0A
	.byte	$10
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
_L2:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$1A
	.byte	$1A
	.byte	$1B
	.byte	$1C
	.byte	$1D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$12
	.byte	$05
	.byte	$05
	.byte	$06
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$16
	.byte	$0E
	.byte	$0E
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$14
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$15
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$11
	.byte	$0A
	.byte	$10
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
_L3:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$19
	.byte	$1A
	.byte	$1B
	.byte	$1C
	.byte	$1D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$12
	.byte	$05
	.byte	$05
	.byte	$06
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$16
	.byte	$0E
	.byte	$0E
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$14
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$15
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$11
	.byte	$0A
	.byte	$10
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
_L4:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$1A
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$1A
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$18
	.byte	$19
	.byte	$1A
	.byte	$1B
	.byte	$1C
	.byte	$1D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$12
	.byte	$05
	.byte	$05
	.byte	$06
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$16
	.byte	$0E
	.byte	$0E
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$14
	.byte	$09
	.byte	$0A
	.byte	$0B
	.byte	$15
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$0C
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$11
	.byte	$0A
	.byte	$10
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
_Title:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$F4
	.byte	$20
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$11
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$11
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$20
	.byte	$01
	.byte	$13
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$16
	.byte	$00
	.byte	$01
	.byte	$12
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$05
	.byte	$00
	.byte	$01
	.byte	$B1
	.byte	$70
	.byte	$92
	.byte	$85
	.byte	$93
	.byte	$93
	.byte	$00
	.byte	$00
	.byte	$73
	.byte	$94
	.byte	$81
	.byte	$92
	.byte	$94
	.byte	$00
	.byte	$01
	.byte	$72
	.byte	$70
	.byte	$85
	.byte	$97
	.byte	$94
	.byte	$85
	.byte	$92
	.byte	$00
	.byte	$70
	.byte	$89
	.byte	$87
	.byte	$85
	.byte	$8F
	.byte	$8E
	.byte	$93
	.byte	$00
	.byte	$01
	.byte	$34
	.byte	$80
	.byte	$01
	.byte	$0A
	.byte	$00
	.byte	$01
	.byte	$0C
	.byte	$20
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$80
	.byte	$20
	.byte	$80
	.byte	$01
	.byte	$0B
	.byte	$00
	.byte	$01
	.byte	$0E
	.byte	$20
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$B4
	.byte	$00
	.byte	$01
	.byte	$00
_death:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$F4
	.byte	$20
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$11
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$11
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$20
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$20
	.byte	$01
	.byte	$13
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$20
	.byte	$00
	.byte	$00
	.byte	$20
	.byte	$01
	.byte	$16
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$79
	.byte	$8F
	.byte	$95
	.byte	$00
	.byte	$84
	.byte	$89
	.byte	$85
	.byte	$84
	.byte	$20
	.byte	$8C
	.byte	$84
	.byte	$89
	.byte	$8F
	.byte	$94
	.byte	$20
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$01
	.byte	$FE
	.byte	$00
	.byte	$01
	.byte	$74
	.byte	$80
	.byte	$01
	.byte	$0A
	.byte	$00
	.byte	$01
	.byte	$0C
	.byte	$20
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$80
	.byte	$20
	.byte	$80
	.byte	$01
	.byte	$0B
	.byte	$00
	.byte	$01
	.byte	$0E
	.byte	$20
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$B4
	.byte	$00
	.byte	$01
	.byte	$00
_ROOMS:
	.addr	_L1
	.addr	_L2
	.addr	_L3
	.addr	_L4
_PLATFORM:
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$06
	.byte	$06
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$32
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_METATILES:
	.byte	$00
	.byte	$01
	.byte	$10
	.byte	$11
	.byte	$02
	.byte	$03
	.byte	$12
	.byte	$13
	.byte	$04
	.byte	$05
	.byte	$14
	.byte	$15
	.byte	$06
	.byte	$07
	.byte	$16
	.byte	$17
	.byte	$08
	.byte	$09
	.byte	$18
	.byte	$19
	.byte	$0A
	.byte	$0B
	.byte	$1A
	.byte	$1B
	.byte	$0C
	.byte	$0D
	.byte	$1C
	.byte	$1D
	.byte	$0E
	.byte	$0F
	.byte	$1E
	.byte	$1F
	.byte	$20
	.byte	$21
	.byte	$30
	.byte	$31
	.byte	$22
	.byte	$23
	.byte	$32
	.byte	$33
	.byte	$24
	.byte	$25
	.byte	$34
	.byte	$35
	.byte	$26
	.byte	$27
	.byte	$36
	.byte	$37
	.byte	$28
	.byte	$29
	.byte	$38
	.byte	$39
	.byte	$2A
	.byte	$2B
	.byte	$3A
	.byte	$3B
	.byte	$2C
	.byte	$2D
	.byte	$3C
	.byte	$3D
	.byte	$2E
	.byte	$2F
	.byte	$3E
	.byte	$3F
	.byte	$A0
	.byte	$A1
	.byte	$B0
	.byte	$B1
	.byte	$A2
	.byte	$A3
	.byte	$B2
	.byte	$B3
	.byte	$A4
	.byte	$A5
	.byte	$B4
	.byte	$B5
	.byte	$A6
	.byte	$A7
	.byte	$B6
	.byte	$B7
	.byte	$A8
	.byte	$A9
	.byte	$B8
	.byte	$B9
	.byte	$AA
	.byte	$AB
	.byte	$BA
	.byte	$BB
	.byte	$AC
	.byte	$AD
	.byte	$BC
	.byte	$BD
	.byte	$AE
	.byte	$AF
	.byte	$BE
	.byte	$BF
	.byte	$C0
	.byte	$C1
	.byte	$D0
	.byte	$D1
	.byte	$C2
	.byte	$C3
	.byte	$D2
	.byte	$D3
	.byte	$C4
	.byte	$C5
	.byte	$D4
	.byte	$D5
	.byte	$C6
	.byte	$C7
	.byte	$D6
	.byte	$D7
	.byte	$C8
	.byte	$C9
	.byte	$D8
	.byte	$D9
	.byte	$CA
	.byte	$CB
	.byte	$DA
	.byte	$DB
	.byte	$CC
	.byte	$CD
	.byte	$DC
	.byte	$DD
	.byte	$CE
	.byte	$CF
	.byte	$DE
	.byte	$DF
	.byte	$E0
	.byte	$E1
	.byte	$F0
	.byte	$F1
	.byte	$E2
	.byte	$E3
	.byte	$F2
	.byte	$F3
	.byte	$E4
	.byte	$E5
	.byte	$F4
	.byte	$F5
	.byte	$E6
	.byte	$E7
	.byte	$F6
	.byte	$F7
	.byte	$E8
	.byte	$E9
	.byte	$F8
	.byte	$F9
	.byte	$EA
	.byte	$EB
	.byte	$FA
	.byte	$FB
	.byte	$EC
	.byte	$ED
	.byte	$FC
	.byte	$FD
	.byte	$EE
	.byte	$EF
	.byte	$FE
	.byte	$FF
	.byte	$26
	.byte	$27
	.byte	$36
	.byte	$37
	.byte	$28
	.byte	$29
	.byte	$38
	.byte	$39
	.byte	$2A
	.byte	$2B
	.byte	$3A
	.byte	$3B
	.byte	$2C
	.byte	$2D
	.byte	$3C
	.byte	$3D
_MT_color:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_HUD:
	.byte	$20,$4C,$69,$76,$65,$73,$3A,$20,$20,$00
_PALETTE:
	.byte	$21
	.byte	$08
	.byte	$0A
	.byte	$0F
	.byte	$21
	.byte	$07
	.byte	$17
	.byte	$0F
	.byte	$21
	.byte	$00
	.byte	$10
	.byte	$1D
	.byte	$21
	.byte	$07
	.byte	$17
	.byte	$27
_Walk_Moves:
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$03
	.byte	$04
_MetaSprite_Y:
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$08
_MetaSprite_Tile_Right:
	.byte	$00
	.byte	$01
	.byte	$10
	.byte	$11
	.byte	$02
	.byte	$03
	.byte	$12
	.byte	$13
	.byte	$04
	.byte	$05
	.byte	$14
	.byte	$15
	.byte	$06
	.byte	$07
	.byte	$16
	.byte	$17
	.byte	$08
	.byte	$09
	.byte	$18
	.byte	$19
	.byte	$0A
	.byte	$0B
	.byte	$1A
	.byte	$1B
	.byte	$0C
	.byte	$0D
	.byte	$1C
	.byte	$1D
_MetaSprite_Attrib_Right:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_MetaSprite_X:
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$08
_MetaSprite_Tile_Left:
	.byte	$01
	.byte	$00
	.byte	$11
	.byte	$10
	.byte	$03
	.byte	$02
	.byte	$13
	.byte	$12
	.byte	$05
	.byte	$04
	.byte	$15
	.byte	$14
	.byte	$07
	.byte	$06
	.byte	$17
	.byte	$16
	.byte	$09
	.byte	$08
	.byte	$19
	.byte	$18
	.byte	$0B
	.byte	$0A
	.byte	$1B
	.byte	$1A
	.byte	$0D
	.byte	$0C
	.byte	$1D
	.byte	$1C
_MetaSprite_Attrib_Left:
	.byte	$40
	.byte	$40
	.byte	$40
	.byte	$40

.segment	"BSS"

.segment	"ZEROPAGE"
_NMI_flag:
	.res	1,$00
_Frame_Count:
	.res	1,$00
_index:
	.res	1,$00
_index2:
	.res	1,$00
_index3:
	.res	1,$00
_index4:
	.res	1,$00
_lives:
	.res	1,$00
_X1:
	.res	1,$00
_Y1:
	.res	1,$00
_state:
	.res	1,$00
_state4:
	.res	1,$00
_joypad1:
	.res	1,$00
_joypad1old:
	.res	1,$00
_joypad1test:
	.res	1,$00
_joypad2:
	.res	1,$00
_joypad2old:
	.res	1,$00
_joypad2test:
	.res	1,$00
_Room:
	.res	1,$00
_RoomB:
	.res	1,$00
_RoomPlus:
	.res	1,$00
_Room_Address:
	.res	2,$00
_Horiz_scroll:
	.res	1,$00
_Horiz_scroll_Old:
	.res	1,$00
_Horiz_scroll_Plus:
	.res	1,$00
_Scroll_Adjusted_X:
	.res	2,$00
_Game_Mode:
	.res	1,$00
_Nametable:
	.res	1,$00
_NametableB:
	.res	1,$00
_Nametable_Plus:
	.res	1,$00
_walk_count:
	.res	1,$00
_X_speed:
	.res	1,$00
_Y_speed:
	.res	1,$00
_direction:
	.res	1,$00
_collision_Index:
	.res	1,$00
_high_byte:
	.res	1,$00
_collision:
	.res	1,$00
_collisionBot:
	.res	1,$00
_collisionOld:
	.res	1,$00
_temp:
	.res	1,$00
_temp2:
	.res	1,$00
_temp3:
	.res	1,$00
_temp4:
	.res	1,$00
_PPU_ADDRESS_High:
	.res	1,$00
_PPU_ADDRESS_Low:
	.res	1,$00
_A:
	.res	1,$00
_PPU_flag:
	.res	1,$00
_PPU_flag2:
	.res	1,$00
_dummy:
	.res	1,$00
.segment	"OAM"
_SPRITE_ZERO:
	.res	4,$00
_SPRITES:
	.res	252,$00
.segment	"MAP"
_C_MAP:
	.res	256,$00
_C_MAP2:
	.res	256,$00
.segment	"BSS"
_BUFFER1:
	.res	32,$00
_BUFFER2:
	.res	32,$00
_BUFFER3:
	.res	32,$00
_BUFFER4:
	.res	32,$00
_BUFFER5:
	.res	8,$00
_BUFFER6:
	.res	8,$00
_BUFFER7:
	.res	8,$00

; ---------------------------------------------------------------
; void __near__ All_Off (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_All_Off: near

.segment	"CODE"

;
; PPU_CTRL = 0;
;
	lda     #$00
	sta     $2000
;
; PPU_MASK = 0;
;
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ All_On (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_All_On: near

.segment	"CODE"

;
; PPU_CTRL = 0x94; // screen is on, NMI on
;
	lda     #$94
	sta     $2000
;
; PPU_MASK = 0x1e;
;
	lda     #$1E
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Reset_Scroll (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Reset_Scroll: near

.segment	"CODE"

;
; PPU_ADDRESS = 0;
;
	lda     #$00
	sta     $2006
;
; PPU_ADDRESS = 0;
;
	sta     $2006
;
; SCROLL = 0;
;
	sta     $2005
;
; SCROLL = 0;
;
	sta     $2005
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Load_Palette (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Load_Palette: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x3f;
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; for (index = 0; index < sizeof(PALETTE); ++index)
;
	sta     _index
L0C43:	lda     _index
	cmp     #$10
	bcs     L0915
;
; PPU_DATA = PALETTE[index];
;
	ldy     _index
	lda     _PALETTE,y
	sta     $2007
;
; for (index = 0; index < sizeof(PALETTE); ++index)
;
	inc     _index
	jmp     L0C43
;
; }
;
L0915:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ update_Sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_Sprites: near

.segment	"CODE"

;
; state4 = state << 2; // shift left 2 = multiply 4
;
	lda     _state
	asl     a
	asl     a
	sta     _state4
;
; index4 = 0;
;
	lda     #$00
	sta     _index4
;
; if (direction == 0)
;
	lda     _direction
	jne     L0C53
;
; for (index = 0; index < 4; ++index)
;
	sta     _index
L0C52:	lda     _index
	cmp     #$04
	bcc     L0C55
;
; }
;
	rts
;
; SPRITES[index4] = MetaSprite_Y[index] + Y1; // relative y + master y
;
L0C55:	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0933
	inx
L0933:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile_Right[index + state4]; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L093A
	inx
L093A:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L0C45
	inx
L0C45:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_Right)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_Right)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib_Right[index]; // attributes, all zero here
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0940
	inx
L0940:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_Right,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0947
	inx
L0947:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Y[index] + Y1 + 16; // relative y + master y
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L094E
	inx
L094E:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	bcc     L0C50
	clc
L0C50:	adc     #$10
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile_Right[index + state4] + 32; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0956
	inx
L0956:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L0C48
	inx
L0C48:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_Right)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_Right)
	lda     (ptr1),y
	clc
	adc     #$20
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib_Right[index]; // attributes, all zero here
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L095D
	inx
L095D:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_Right,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0964
	inx
L0964:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index)
;
	inc     _index
	jmp     L0C52
;
; for (index = 0; index < 4; ++index)
;
L0C53:	lda     #$00
	sta     _index
L0C54:	lda     _index
	cmp     #$04
	bcc     L0C56
;
; }
;
	rts
;
; SPRITES[index4] = MetaSprite_Y[index] + Y1; // relative y + master y
;
L0C56:	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0974
	inx
L0974:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile_Left[index + state4]; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L097B
	inx
L097B:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L0C4B
	inx
L0C4B:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_Left)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_Left)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib_Left[index]; // attributes, all zero here
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0981
	inx
L0981:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_Left,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0988
	inx
L0988:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Y[index] + Y1 + 16; // relative y + master y
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L098F
	inx
L098F:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	bcc     L0C51
	clc
L0C51:	adc     #$10
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile_Left[index + state4] + 32; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0997
	inx
L0997:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L0C4E
	inx
L0C4E:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_Left)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_Left)
	lda     (ptr1),y
	clc
	adc     #$20
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib_Left[index]; // attributes, all zero here
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L099E
	inx
L099E:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_Left,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L09A5
	inx
L09A5:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index)
;
	inc     _index
	jmp     L0C54

.endproc

; ---------------------------------------------------------------
; void __near__ Collision_Down (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Collision_Down: near

.segment	"CODE"

;
; if (NametableB == 0)
;
	lda     _NametableB
	bne     L09AB
;
; temp = C_MAP[collision_Index];
;
	ldy     _collision_Index
	lda     _C_MAP,y
;
; else
;
	jmp     L0C5C
;
; temp = C_MAP2[collision_Index];
;
L09AB:	ldy     _collision_Index
	lda     _C_MAP2,y
L0C5C:	sta     _temp
;
; collision += PLATFORM[temp];
;
	ldy     _temp
	lda     _PLATFORM,y
	clc
	adc     _collision
	sta     _collision
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ move_logic (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_move_logic: near

.segment	"CODE"

;
; if ((joypad1 & (RIGHT | LEFT)) == 0)
;
	lda     _joypad1
	and     #$03
	bne     L0C6B
;
; walk_count = 0;
;
	sta     _walk_count
;
; if (X_speed >= 0)
;
	ldx     _X_speed
	bmi     L09C6
;
; if (X_speed >= 4)
;
	lda     _X_speed
	sec
	sbc     #$04
	bvs     L09CC
	eor     #$80
L09CC:	asl     a
	lda     #$00
	bcc     L0C6A
;
; X_speed -= 4;
;
	lda     _X_speed
	sec
	sbc     #$04
	sta     _X_speed
	bpl     L0C6B
;
; else
;
	jmp     L0C6B
;
; if (X_speed <= (-4))
;
L09C6:	lda     _X_speed
	sec
	sbc     #$FD
	bvc     L09D8
	eor     #$80
L09D8:	asl     a
	lda     #$00
	bcc     L0C6A
;
; X_speed += 4;
;
	lda     #$04
	clc
	adc     _X_speed
	sta     _X_speed
	bpl     L0C6B
;
; else
;
	jmp     L0C6B
;
; X_speed = 0; // just stop
;
L0C6A:	sta     _X_speed
;
; if ((joypad1 & RIGHT) != 0)
;
L0C6B:	lda     _joypad1
	and     #$01
	beq     L0C6D
;
; ++walk_count;
;
	inc     _walk_count
;
; direction = 0;
;
	lda     #$00
	sta     _direction
;
; if (X_speed >= 0)
;
	ldx     _X_speed
	bmi     L09E6
;
; X_speed += 2;
;
	lda     #$02
	clc
	adc     _X_speed
	sta     _X_speed
	bpl     L0C6D
;
; else
;
	jmp     L0C6D
;
; X_speed += 8; // just stop
;
L09E6:	lda     #$08
	clc
	adc     _X_speed
	sta     _X_speed
;
; if (X_speed >= 0)
;
	tax
	bmi     L0C6D
;
; X_speed = 0;
;
	lda     #$00
	sta     _X_speed
;
; if ((joypad1 & LEFT) != 0)
;
L0C6D:	lda     _joypad1
	and     #$02
	beq     L0C70
;
; ++walk_count;
;
	inc     _walk_count
;
; direction = 1;
;
	lda     #$01
	sta     _direction
;
; if (X_speed <= 0)
;
	lda     _X_speed
	sec
	sbc     #$01
	bvc     L09FF
	eor     #$80
L09FF:	bpl     L0C6E
;
; X_speed -= 2;
;
	lda     _X_speed
	sec
	sbc     #$02
	sta     _X_speed
	bpl     L0C70
;
; else
;
	jmp     L0C70
;
; X_speed -= 8; //just stop
;
L0C6E:	lda     _X_speed
	sec
	sbc     #$08
	sta     _X_speed
;
; if (X_speed < 0)
;
	asl     a
	bcc     L0C70
;
; X_speed = 0;
;
	lda     #$00
	sta     _X_speed
;
; NametableB = Nametable;
;
L0C70:	lda     _Nametable
	sta     _NametableB
;
; Scroll_Adjusted_X = (X1 + Horiz_scroll + 3); // left
;
	ldx     #$00
	lda     _X1
	clc
	adc     _Horiz_scroll
	bcc     L0C65
	inx
	clc
L0C65:	adc     #$03
	bcc     L0A11
	inx
L0A11:	sta     _Scroll_Adjusted_X
	stx     _Scroll_Adjusted_X+1
;
; high_byte = Scroll_Adjusted_X >> 8;
;
	lda     _Scroll_Adjusted_X+1
	sta     _high_byte
;
; if (high_byte != 0)
;
	lda     _high_byte
	beq     L0C72
;
; ++NametableB; // the other nametable's collision map
;
	inc     _NametableB
;
; NametableB &= 1; // keep it 0 or 1
;
	lda     _NametableB
	and     #$01
	sta     _NametableB
;
; collision = 0;
;
	lda     #$00
L0C72:	sta     _collision
;
; collisionBot = 0;
;
	sta     _collisionBot
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 32) & 0xf0)); //bottom left
;
	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$20
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; Collision_Down();
;
	jsr     _Collision_Down
;
; collisionBot += collision;            // if on platform, ++collision
;
	lda     _collision
	clc
	adc     _collisionBot
	sta     _collisionBot
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1)&0xf0)); //top left
;
	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; Collision_Down();
;
	jsr     _Collision_Down
;
; NametableB = Nametable;
;
	lda     _Nametable
	sta     _NametableB
;
; Scroll_Adjusted_X = (X1 + Horiz_scroll + 13); // left
;
	ldx     #$00
	lda     _X1
	clc
	adc     _Horiz_scroll
	bcc     L0C66
	inx
	clc
L0C66:	adc     #$0D
	bcc     L0A33
	inx
L0A33:	sta     _Scroll_Adjusted_X
	stx     _Scroll_Adjusted_X+1
;
; high_byte = Scroll_Adjusted_X >> 8;
;
	lda     _Scroll_Adjusted_X+1
	sta     _high_byte
;
; if (high_byte != 0)
;
	lda     _high_byte
	beq     L0C73
;
; ++NametableB; // the other nametable's collision map
;
	inc     _NametableB
;
; NametableB &= 1; // keep it 0 or 1
;
	lda     _NametableB
	and     #$01
	sta     _NametableB
;
; collisionOld = collision;
;
L0C73:	lda     _collision
	sta     _collisionOld
;
; collision = 0;
;
	lda     #$00
	sta     _collision
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 32) & 0xf0)); //bottom right
;
	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$20
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; Collision_Down();               // if on platform, ++collision
;
	jsr     _Collision_Down
;
; collisionBot += collision;
;
	lda     _collision
	clc
	adc     _collisionBot
	sta     _collisionBot
;
; collision = collisionOld + collision;
;
	lda     _collisionOld
	clc
	adc     _collision
	sta     _collision
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1)&0xf0)); //top right
;
	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; Collision_Down();              // if on platform, ++collision
;
	jsr     _Collision_Down
;
; if (collision >= 50)
;
	lda     _collision
	cmp     #$32
	bcc     L0C75
;
; Y1 = 0x70;
;
	lda     #$70
	sta     _Y1
;
; Horiz_scroll = 0x80;
;
	lda     #$80
	sta     _Horiz_scroll
;
; NametableB = Nametable;
;
	lda     _Nametable
	sta     _NametableB
;
; --lives;
;
	dec     _lives
;
; if (lives == 0) {
;
	lda     _lives
	beq     L0C97
;
; }
;
	rts
;
; NMI_flag = 0;
;
L0C97:	sta     _NMI_flag
;
; while (NMI_flag == 0); // wait till v-blank
;
L0C74:	lda     _NMI_flag
	beq     L0C74
;
; Game_Mode = GAME_OVER_MODE;
;
	lda     #$03
	sta     _Game_Mode
;
; All_Off(); // turn off screen
;
	jsr     _All_Off
;
; Draw_Death();
;
	jsr     _Draw_Death
;
; X1 = 0x80; // starting position
;
	lda     #$80
	sta     _X1
;
; Y1 = 0x70; // middle of screen
;
	lda     #$70
	sta     _Y1
;
; Set_Sprite_Zero();
;
	jsr     _Set_Sprite_Zero
;
; PPU_CTRL = 0x90; // rightward increments to PPU
;
	lda     #$90
	sta     $2000
;
; Load_Palette();
;
	jsr     _Load_Palette
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; setupAudio();
;
	jsr     _setupAudio
;
; Wait_Vblank();
;
	jsr     _Wait_Vblank
;
; All_On(); // turn on screen
;
	jmp     _All_On
;
; if (Y_speed >= 0)
;
L0C75:	ldx     _Y_speed
	bmi     L0A74
;
; if ((Y1 & 0x0f) > 1) // only platform collide if nearly aligned to a metatile
;
	lda     _Y1
	and     #$0F
	cmp     #$02
	bcc     L0C76
;
; collisionBot = 0;
;
	lda     #$00
	sta     _collisionBot
;
; if (collisionBot == 0)
;
L0C76:	lda     _collisionBot
	bne     L0C77
;
; Y_speed += 4; // gravity
;
	lda     #$04
	clc
	adc     _Y_speed
	sta     _Y_speed
	bpl     L0C7B
;
; else
;
	jmp     L0C7B
;
; Y_speed = 0; // collision = stop falling
;
L0C77:	lda     #$00
	sta     _Y_speed
;
; Y1 &= 0xf0;  // align to the metatile
;
	lda     _Y1
	and     #$F0
;
; else
;
	jmp     L0C91
;
; Y_speed += 4;
;
L0A74:	lda     #$04
	clc
	adc     _Y_speed
	sta     _Y_speed
;
; if (collision < 5 && collision > 0)
;
	lda     _collision
	cmp     #$05
	bcs     L0C7B
	lda     _collision
	beq     L0C7B
;
; Y_speed = 1;
;
	lda     #$01
	sta     _Y_speed
;
; Y1 += 2;
;
	lda     #$02
	clc
	adc     _Y1
L0C91:	sta     _Y1
;
; if (collision > 0)
;
L0C7B:	lda     _collision
	beq     L0C7F
;
; if (((joypad1 & A_BUTTON) != 0) && ((joypad1old & A_BUTTON) == 0))
;
	lda     _joypad1
	and     #$80
	beq     L0C7F
	lda     _joypad1old
	and     #$80
	bne     L0C7F
;
; Y_speed = -0x68; // 0xc8
;
	lda     #$98
	sta     _Y_speed
;
; if (collision > 0)
;
	lda     _collision
	beq     L0C7F
;
; audioBeep();
;
	jsr     _audioBeep
;
; if (X_speed >= 0)
;
L0C7F:	ldx     _X_speed
	bmi     L0AA3
;
; if (X_speed > 0x20)
;
	lda     _X_speed
	sec
	sbc     #$21
	bvs     L0AA9
	eor     #$80
L0AA9:	bpl     L0C80
;
; X_speed = 0x20;
;
	lda     #$20
;
; else
;
	jmp     L0C62
;
; if (X_speed < -0x20)
;
L0AA3:	lda     _X_speed
	sec
	sbc     #$E0
	bvc     L0AB0
	eor     #$80
L0AB0:	bpl     L0C80
;
; X_speed = -0x20; // -0x20
;
	lda     #$E0
L0C62:	sta     _X_speed
;
; if (Y_speed >= 0)
;
L0C80:	ldx     _Y_speed
	bmi     L0C81
;
; if (Y_speed > 0x20)
;
	lda     _Y_speed
	sec
	sbc     #$21
	bvs     L0AB9
	eor     #$80
L0AB9:	bpl     L0C81
;
; Y_speed = 0x20;
;
	lda     #$20
	sta     _Y_speed
;
; Horiz_scroll_Old = Horiz_scroll;
;
L0C81:	lda     _Horiz_scroll
	sta     _Horiz_scroll_Old
;
; if (X_speed != 0)
;
	lda     _X_speed
	jeq     L0C86
;
; Horiz_scroll_Old = Horiz_scroll;
;
	lda     _Horiz_scroll
	sta     _Horiz_scroll_Old
;
; Horiz_scroll += (X_speed >> 4); // use the high nibble
;
	ldx     #$00
	lda     _X_speed
	bpl     L0AC6
	dex
L0AC6:	jsr     asrax4
	clc
	adc     _Horiz_scroll
	sta     _Horiz_scroll
;
; NametableB = Nametable;
;
	lda     _Nametable
	sta     _NametableB
;
; Scroll_Adjusted_X = (X1 + Horiz_scroll + (X_speed < 0 ? 3 : 13)); // left
;
	ldx     #$00
	lda     _X1
	clc
	adc     _Horiz_scroll
	bcc     L0C60
	inx
L0C60:	sta     ptr1
	stx     ptr1+1
	lda     _X_speed
	asl     a
	bcc     L0C82
	lda     #$03
	jmp     L0AD0
L0C82:	lda     #$0D
L0AD0:	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L0C61
	inx
L0C61:	sta     _Scroll_Adjusted_X
	stx     _Scroll_Adjusted_X+1
;
; high_byte = Scroll_Adjusted_X >> 8;
;
	lda     _Scroll_Adjusted_X+1
	sta     _high_byte
;
; if (high_byte != 0)
;
	lda     _high_byte
	beq     L0C84
;
; ++NametableB; // the other nametable's collision map
;
	inc     _NametableB
;
; NametableB &= 1; // keep it 0 or 1
;
	lda     _NametableB
	and     #$01
	sta     _NametableB
;
; collision = 0;                       // if on platform, ++collision
;
	lda     #$00
L0C84:	sta     _collision
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 31) & 0xf0)); //top left if on ground / falling, bottom left if in air
;
	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$1F
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; Collision_Down();
;
	jsr     _Collision_Down
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 16) & 0xf0)); //top left if on ground / falling, bottom left if in air
;
	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$10
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; Collision_Down();
;
	jsr     _Collision_Down
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1)&0xf0)); //top left if on ground / falling, bottom left if in air
;
	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; Collision_Down();
;
	jsr     _Collision_Down
;
; if (collision > 0)
;
	lda     _collision
	beq     L0C85
;
; Horiz_scroll = Horiz_scroll_Old;
;
	lda     _Horiz_scroll_Old
	sta     _Horiz_scroll
;
; X_speed = 0;
;
	lda     #$00
	sta     _X_speed
;
; else
;
	jmp     L0C86
;
; if (X_speed >= 0)
;
L0C85:	ldx     _X_speed
	bmi     L0AF9
;
; if (Horiz_scroll_Old > Horiz_scroll) { // if pass 0, switch nametables
;
	lda     _Horiz_scroll_Old
	sec
	sbc     _Horiz_scroll
	bcc     L0C86
	beq     L0C86
;
; ++Nametable;
;
	inc     _Nametable
;
; ++Room;
;
	inc     _Room
;
; else
;
	jmp     L0C86
;
; if (Horiz_scroll_Old < Horiz_scroll) {
;
L0AF9:	lda     _Horiz_scroll_Old
	cmp     _Horiz_scroll
	bcs     L0C86
;
; ++Nametable; // if pass 0, switch nametables
;
	inc     _Nametable
;
; --Room;
;
	dec     _Room
;
; Nametable &= 1; // keep it 1 or 0
;
L0C86:	lda     _Nametable
	and     #$01
	sta     _Nametable
;
; Room &= 3;  // keep it 0-3
;
	lda     _Room
	and     #$03
	sta     _Room
;
; Y1 += (Y_speed >> 4); // use the high nibble
;
	ldx     #$00
	lda     _Y_speed
	bpl     L0B14
	dex
L0B14:	jsr     asrax4
	clc
	adc     _Y1
	sta     _Y1
;
; if (walk_count > 0x29) // walk_count forced 0-29
;
	lda     _walk_count
	cmp     #$2A
	ldx     #$00
	bcc     L0C87
;
; walk_count = 0;
;
	stx     _walk_count
;
; state = Walk_Moves[(walk_count >> 3)]; // if not jumping
;
L0C87:	lda     _walk_count
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	txa
	clc
	adc     #>(_Walk_Moves)
	sta     ptr1+1
	ldy     #<(_Walk_Moves)
	lda     (ptr1),y
	sta     _state
;
; if (X_speed == 0 && Y_speed == 0) 
;
	lda     _X_speed
	bne     L0C88
	lda     _Y_speed
	bne     L0C88
;
; state = 2;
;
	lda     #$02
	sta     _state
;
; if (Y_speed < 0) // negative = jumping
;
L0C88:	lda     _Y_speed
	asl     a
	bcc     L0C89
;
; state = 5;
;
	lda     #$05
	sta     _state
;
; if (Y_speed > 0) // negative = jumping
;
L0C89:	lda     _Y_speed
	sec
	sbc     #$01
	bvs     L0B2D
	eor     #$80
L0B2D:	bpl     L0B2A
;
; state = 6;
;
	lda     #$06
	sta     _state
;
; }
;
L0B2A:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Do_Buffer (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Do_Buffer: near

.segment	"CODE"

;
; Buffer_Tiles();
;
	jsr     _Buffer_Tiles
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; Buffer_Tiles2();
;
	jsr     _Buffer_Tiles2
;
; Horiz_scroll_Plus -= 0x10;
;
	lda     _Horiz_scroll_Plus
	sec
	sbc     #$10
	sta     _Horiz_scroll_Plus
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Do_Buffer2 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Do_Buffer2: near

.segment	"CODE"

;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L0C99
;
; PPU_ADDRESS_High = 0x24;
;
	lda     #$24
;
; else
;
	jmp     L0C98
;
; PPU_ADDRESS_High = 0x20;
;
L0C99:	lda     #$20
L0C98:	sta     _PPU_ADDRESS_High
;
; PPU_ADDRESS_Low = ((Horiz_scroll_Plus & 0xf0) >> 3) + 0x80; // +80 because we're skipping the top
;
	lda     _Horiz_scroll_Plus
	and     #$F0
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     #$80
	sta     _PPU_ADDRESS_Low
;
; PPU_ADDRESS = PPU_ADDRESS_High;
;
	lda     _PPU_ADDRESS_High
	sta     $2006
;
; PPU_ADDRESS = PPU_ADDRESS_Low;
;
	lda     _PPU_ADDRESS_Low
	sta     $2006
;
; Super_Fast_Write_PPU();
;
	jmp     _Super_Fast_Write_PPU

.endproc

; ---------------------------------------------------------------
; void __near__ Do_Buffer3 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Do_Buffer3: near

.segment	"CODE"

;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L0C9B
;
; PPU_ADDRESS_High = 0x24;
;
	lda     #$24
;
; else
;
	jmp     L0C9A
;
; PPU_ADDRESS_High = 0x20;
;
L0C9B:	lda     #$20
L0C9A:	sta     _PPU_ADDRESS_High
;
; PPU_ADDRESS_Low = ((Horiz_scroll_Plus & 0xf0) >> 3) + 0x80; // +80 because we're skipping the top
;
	lda     _Horiz_scroll_Plus
	and     #$F0
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     #$80
	sta     _PPU_ADDRESS_Low
;
; PPU_ADDRESS = PPU_ADDRESS_High;
;
	lda     _PPU_ADDRESS_High
	sta     $2006
;
; PPU_ADDRESS = PPU_ADDRESS_Low;
;
	lda     _PPU_ADDRESS_Low
	sta     $2006
;
; Super_Fast_Write_PPU2();
;
	jmp     _Super_Fast_Write_PPU2

.endproc

; ---------------------------------------------------------------
; void __near__ Draw_Title (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Draw_Title: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x20; // address of nametable #0 = 0x2000
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; UnRLE(Title); // uncompresses our data
;
	lda     #<(_Title)
	ldx     #>(_Title)
	jsr     _UnRLE
;
; PPU_ADDRESS = 0x27;
;
	lda     #$27
	sta     $2006
;
; PPU_ADDRESS = 0xc0;
;
	lda     #$C0
	sta     $2006
;
; for (index = 0; index < 8; ++index)
;
	lda     #$00
	sta     _index
L0C9C:	lda     _index
	cmp     #$08
	bcs     L0BE8
;
; PPU_DATA = 0xff;
;
	lda     #$FF
	sta     $2007
;
; for (index = 0; index < 8; ++index)
;
	inc     _index
	jmp     L0C9C
;
; }
;
L0BE8:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Draw_Death (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Draw_Death: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x20; // address of nametable #0 = 0x2000
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; UnRLE(death); // uncompresses our data
;
	lda     #<(_death)
	ldx     #>(_death)
	jsr     _UnRLE
;
; PPU_ADDRESS = 0x27;
;
	lda     #$27
	sta     $2006
;
; PPU_ADDRESS = 0xc0;
;
	lda     #$C0
	sta     $2006
;
; for (index = 0; index < 8; ++index)
;
	lda     #$00
	sta     _index
L0C9D:	lda     _index
	cmp     #$08
	bcs     L0BCE
;
; PPU_DATA = 0xff;
;
	lda     #$FF
	sta     $2007
;
; for (index = 0; index < 8; ++index)
;
	inc     _index
	jmp     L0C9D
;
; }
;
L0BCE:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Draw_Background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Draw_Background: near

.segment	"CODE"

;
; memcpy(C_MAP, L1, 240);
;
	lda     #<(_C_MAP)
	ldx     #>(_C_MAP)
	jsr     pushax
	lda     #<(_L1)
	ldx     #>(_L1)
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; memcpy(C_MAP2, L2, 240);
;
	lda     #<(_C_MAP2)
	ldx     #>(_C_MAP2)
	jsr     pushax
	lda     #<(_L2)
	ldx     #>(_L2)
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; Nametable_Plus = 1;
;
	lda     #$01
	sta     _Nametable_Plus
;
; PPU_CTRL = 4; // sets to downward increments when writing to PPU
;
	lda     #$04
	sta     $2000
;
; for (A = 0; A < 8; ++A)
;
	lda     #$00
	sta     _A
L0C9E:	lda     _A
	cmp     #$08
	bcs     L0C9F
;
; Do_Buffer();  // fill buffer
;
	jsr     _Do_Buffer
;
; Do_Buffer2(); // draw to ppu
;
	jsr     _Do_Buffer2
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; Do_Buffer3(); // draw to ppu
;
	jsr     _Do_Buffer3
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; for (A = 0; A < 8; ++A)
;
	inc     _A
	jmp     L0C9E
;
; --Nametable_Plus;
;
L0C9F:	dec     _Nametable_Plus
;
; for (A = 0; A < 8; ++A)
;
	lda     #$00
	sta     _A
L0CA0:	lda     _A
	cmp     #$08
	bcs     L0B7E
;
; Do_Buffer();  // fill buffer
;
	jsr     _Do_Buffer
;
; Do_Buffer2(); // draw to ppu
;
	jsr     _Do_Buffer2
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; Do_Buffer3(); // draw to ppu
;
	jsr     _Do_Buffer3
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; for (A = 0; A < 8; ++A)
;
	inc     _A
	jmp     L0CA0
;
; }
;
L0B7E:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Set_Sprite_Zero (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Set_Sprite_Zero: near

.segment	"CODE"

;
; SPRITE_ZERO[0] = 0x15; // y
;
	lda     #$15
	sta     _SPRITE_ZERO
;
; SPRITE_ZERO[1] = 0x9C; // tile
;
	lda     #$9C
	sta     _SPRITE_ZERO+1
;
; SPRITE_ZERO[2] = 0; // attributes
;
	lda     #$00
	sta     _SPRITE_ZERO+2
;
; SPRITE_ZERO[3] = 0x13; // x
;
	lda     #$13
	sta     _SPRITE_ZERO+3
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Load_HUD (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Load_HUD: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x20;
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = 0x42;
;
	lda     #$42
	sta     $2006
;
; for (index = 0; index < sizeof(HUD); ++index)
;
	lda     #$00
	sta     _index
L0CA1:	lda     _index
	cmp     #$0A
	bcs     L0BA1
;
; PPU_DATA = HUD[index] + 32;
;
	ldy     _index
	lda     _HUD,y
	clc
	adc     #$20
	sta     $2007
;
; for (index = 0; index < sizeof(HUD); ++index)
;
	inc     _index
	jmp     L0CA1
;
; }
;
L0BA1:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Should_We_Buffer (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Should_We_Buffer: near

.segment	"CODE"

;
; if (direction == 0)
;
	lda     _direction
	bne     L0BB8
;
; if ((Horiz_scroll_Plus & 0x1e) == 0x02)
;
	lda     _Horiz_scroll_Plus
	and     #$1E
	cmp     #$02
	bne     L0CA2
;
; Buffer_Tiles();
;
	jsr     _Buffer_Tiles
;
; ++PPU_flag;
;
	inc     _PPU_flag
;
; if ((Horiz_scroll_Plus & 0x1e) == 0x10)
;
L0CA2:	lda     _Horiz_scroll_Plus
	and     #$1E
	cmp     #$10
	bne     L0BB8
;
; Buffer_Tiles2();
;
	jsr     _Buffer_Tiles2
;
; ++PPU_flag2;
;
	inc     _PPU_flag2
;
; }
;
L0BB8:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ New_Room (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_New_Room: near

.segment	"CODE"

;
; RoomB = RoomPlus + 1;
;
	lda     _RoomPlus
	clc
	adc     #$01
	sta     _RoomB
;
; RoomB &= 3;      // keep it 0-3, we only have 4 rooms
;
	and     #$03
	sta     _RoomB
;
; Room_Address = ROOMS[RoomB]; // get the address of the room data
;
	ldx     #$00
	lda     _RoomB
	asl     a
	bcc     L0CA8
	inx
	clc
L0CA8:	adc     #<(_ROOMS)
	sta     ptr1
	txa
	adc     #>(_ROOMS)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _Room_Address+1
	dey
	lda     (ptr1),y
	sta     _Room_Address
;
; A = Horiz_scroll_Plus >> 4;
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     _A
;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L0CAA
;
; for (index = 0; index < 15; ++index)
;
	sta     _index
	tax
L0CA9:	lda     _index
	cmp     #$0F
	bcs     L0CAC
;
; C_MAP2[A] = Room_Address[A];
;
	lda     #<(_C_MAP2)
	ldx     #>(_C_MAP2)
	clc
	adc     _A
	bcc     L0C09
	inx
L0C09:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	ldx     #$00
	inc     _index
	jmp     L0CA9
;
; for (index = 0; index < 15; ++index)
;
L0CAA:	tya
	sta     _index
	tax
L0CAB:	lda     _index
	cmp     #$0F
	bcs     L0CAC
;
; C_MAP[A] = Room_Address[A];
;
	lda     #<(_C_MAP)
	ldx     #>(_C_MAP)
	clc
	adc     _A
	bcc     L0C19
	inx
L0C19:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	ldx     #$00
	inc     _index
	jmp     L0CAB
;
; A = (Horiz_scroll_Plus + 0x10) >> 4;
;
L0CAC:	lda     _Horiz_scroll_Plus
	clc
	adc     #$10
	bcc     L0C21
	inx
L0C21:	jsr     shrax4
	sta     _A
;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L0CAE
;
; for (index = 0; index < 15; ++index)
;
	sta     _index
L0CAD:	lda     _index
	cmp     #$0F
	bcs     L0C35
;
; C_MAP2[A] = Room_Address[A];
;
	lda     #<(_C_MAP2)
	ldx     #>(_C_MAP2)
	clc
	adc     _A
	bcc     L0C2E
	inx
L0C2E:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	inc     _index
	jmp     L0CAD
;
; for (index = 0; index < 15; ++index)
;
L0CAE:	lda     #$00
	sta     _index
L0CAF:	lda     _index
	cmp     #$0F
	bcs     L0C35
;
; C_MAP[A] = Room_Address[A];
;
	lda     #<(_C_MAP)
	ldx     #>(_C_MAP)
	clc
	adc     _A
	bcc     L0C3E
	inx
L0C3E:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	inc     _index
	jmp     L0CAF
;
; }
;
L0C35:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Buffer_Tiles (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Buffer_Tiles: near

.segment	"CODE"

;
; index = 2;  // will be skipping the top 2 metatiles, it's the HUD
;
	lda     #$02
	sta     _index
;
; index2 = 0;
;
	lda     #$00
	sta     _index2
;
; index3 = 0;
;
	tax
	sta     _index3
;
; while (index < 15){ 
;
	jmp     L0CB5
;
; if (Nametable_Plus == 0){ // drawing to the opposite screen that we're on
;
L0CB2:	lda     _Nametable_Plus
	bne     L0CB3
;
; temp = C_MAP2[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the metatile
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else{
;
	jmp     L0CB6
;
; temp = C_MAP[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the metatile
;
L0CB3:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L0CB6:	lda     (ptr1),y
	sta     _temp
;
; temp3 = MT_color[temp]; // get color, store temp
;
	ldy     _temp
	lda     _MT_color,y
	sta     _temp3
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER1[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L0657
	inx
L0657:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L065E
	inx
L065E:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER1[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L0666
	inx
L0666:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L066D
	inx
L066D:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; ++index; // next round, difference is attribute table stuff
;
	inc     _index
;
; if (Nametable_Plus == 0){ // read from 2nd map
;
	ldx     #$00
	lda     _Nametable_Plus
	bne     L0CB4
;
; temp = C_MAP2[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the metatile
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else{
;
	jmp     L0CB7
;
; temp = C_MAP[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the metatile
;
L0CB4:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L0CB7:	lda     (ptr1),y
	sta     _temp
;
; temp3 += (MT_color[temp] << 4); // get color, store temp
;
	ldy     _temp
	lda     _MT_color,y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     _temp3
	sta     _temp3
;
; BUFFER5[index3] = temp3;
;
	ldy     _index3
	lda     _temp3
	sta     _BUFFER5,y
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER1[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L068E
	inx
L068E:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L0695
	inx
L0695:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER1[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L069D
	inx
L069D:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L06A4
	inx
L06A4:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index2;
;
	inc     _index2
;
; ++index3;
;
	inc     _index3
;
; ++index;
;
	inc     _index
;
; while (index < 15){ 
;
	ldx     #$00
L0CB5:	lda     _index
	cmp     #$0F
	jcc     L0CB2
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Buffer_Tiles2 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Buffer_Tiles2: near

.segment	"CODE"

;
; index = 2; // will be skipping the top 2 metatiles, later
;
	lda     #$02
	sta     _index
;
; index2 = 0;
;
	lda     #$00
	sta     _index2
;
; index3 = 0;
;
	tax
	sta     _index3
;
; while (index < 15){
;
	jmp     L0CBE
;
; if (Nametable_Plus == 0){ // drawing to the opposite screen that we're on
;
L0CBB:	lda     _Nametable_Plus
	bne     L0CBC
;
; temp = C_MAP2[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the mt
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else{
;
	jmp     L0CC0
;
; temp = C_MAP[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the mt
;
L0CBC:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L0CC0:	lda     (ptr1),y
	sta     _temp
;
; temp3 = MT_color[temp]; // get palette #, store temp3
;
	ldy     _temp
	lda     _MT_color,y
	sta     _temp3
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER3[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L06CB
	inx
L06CB:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L06D2
	inx
L06D2:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER3[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L06DA
	inx
L06DA:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L06E1
	inx
L06E1:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; ++index; // next round, difference is attribute table stuff
;
	inc     _index
;
; if (Nametable_Plus == 0){ // read from 2nd map
;
	ldx     #$00
	lda     _Nametable_Plus
	bne     L0CBD
;
; temp = C_MAP2[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the mt
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else{
;
	jmp     L0CC1
;
; temp = C_MAP[(Horiz_scroll_Plus>>4) + (index<<4)]; // get the mt
;
L0CBD:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L0CC1:	lda     (ptr1),y
	sta     _temp
;
; temp3 += (MT_color[temp] << 4); // get palette #, store temp3
;
	ldy     _temp
	lda     _MT_color,y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     _temp3
	sta     _temp3
;
; BUFFER6[index3] = temp3 << 2;
;
	lda     #<(_BUFFER6)
	ldx     #>(_BUFFER6)
	clc
	adc     _index3
	bcc     L06FC
	inx
L06FC:	sta     ptr1
	stx     ptr1+1
	lda     _temp3
	asl     a
	asl     a
	ldy     #$00
	sta     (ptr1),y
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER3[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L0702
	inx
L0702:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L0709
	inx
L0709:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER3[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L0711
	inx
L0711:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L0718
	inx
L0718:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index2;
;
	inc     _index2
;
; ++index3;
;
	inc     _index3
;
; ++index;
;
	inc     _index
;
; while (index < 15){
;
	ldx     #$00
L0CBE:	lda     _index
	cmp     #$0F
	jcc     L0CBB
;
; for (index=0;index<8;++index){
;
	stx     _index
L0CBF:	lda     _index
	cmp     #$08
	bcs     L0720
;
; BUFFER7[index] = BUFFER5[index] + BUFFER6[index]; 
;
	lda     #<(_BUFFER7)
	ldx     #>(_BUFFER7)
	clc
	adc     _index
	bcc     L0729
	inx
L0729:	sta     sreg
	stx     sreg+1
	ldy     _index
	lda     _BUFFER5,y
	sta     ptr1
	ldy     _index
	lda     _BUFFER6,y
	clc
	adc     ptr1
	ldy     #$00
	sta     (sreg),y
;
; for (index=0;index<8;++index){
;
	inc     _index
	jmp     L0CBF
;
; }
;
L0720:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ setupAudio (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setupAudio: near

.segment	"CODE"

;
; *((unsigned char*)0x4015) = 0x0f;
;
	lda     #$0F
	sta     $4015
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ audioUpdate (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_audioUpdate: near

.segment	"CODE"

;
; ++currentTick;
;
	inc     _currentTick
;
; if(currentState == SONG_TEST)
;
	lda     _currentState
	cmp     #$00
;
; bossaSong();
;
	jeq     _bossaSong
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ audioBeep (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_audioBeep: near

.segment	"CODE"

;
; if ((joypad1 & A_BUTTON) != 0){
;
	lda     _joypad1
	and     #$80
	beq     L07CC
;
; *((unsigned char*)0x4000) = 0x0f;
;
	lda     #$0F
	sta     $4000
;
; *((unsigned char*)0x4003) = 0x01;
;
	lda     #$01
	sta     $4003
;
; }
;
L07CC:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ playSquare (unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_playSquare: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; voice *= 4;
;
	ldy     #$00
	lda     (sp),y
	asl     a
	asl     a
	sta     (sp),y
;
; *((unsigned char*)(0x4000 + voice)) = 0x8f;
;
	sta     ptr1
	tya
	clc
	adc     #$40
	sta     ptr1+1
	lda     #$8F
	sta     (ptr1),y
;
; *((unsigned char*)(0x4001 + voice)) = 0x00;
;
	lda     (sp),y
	clc
	adc     #$01
	sta     ptr1
	tya
	adc     #$40
	sta     ptr1+1
	tya
	sta     (ptr1),y
;
; *((unsigned char*)(0x4002 + voice)) = notes[note];
;
	lda     (sp),y
	clc
	adc     #$02
	pha
	tya
	adc     #$40
	tax
	pla
	jsr     pushax
	ldy     #$03
	lda     (sp),y
	tay
	lda     _notes,y
	ldy     #$00
	jsr     staspidx
;
; if(note < 5)   *((unsigned char*)(0x4003 + voice)) = 0x13;
;
	ldy     #$01
	lda     (sp),y
	cmp     #$05
	bcs     L0CC4
	dey
	lda     (sp),y
	clc
	adc     #$03
	sta     ptr1
	tya
	adc     #$40
	sta     ptr1+1
	lda     #$13
;
; else if(note < 12)  *((unsigned char*)(0x4003 + voice)) = 0x12;
;
	jmp     L0CC2
L0CC4:	lda     (sp),y
	cmp     #$0C
	bcs     L0CC6
	dey
	lda     (sp),y
	clc
	adc     #$03
	sta     ptr1
	tya
	adc     #$40
	sta     ptr1+1
	lda     #$12
;
; else if(note < 24)  *((unsigned char*)(0x4003 + voice)) = 0x11;
;
	jmp     L0CC2
L0CC6:	lda     (sp),y
	cmp     #$18
	bcs     L07F5
	dey
	lda     (sp),y
	clc
	adc     #$03
	sta     ptr1
	tya
	adc     #$40
	sta     ptr1+1
	lda     #$11
;
; else     *((unsigned char*)(0x4003 + voice)) = 0x10;
;
	jmp     L0CC2
L07F5:	dey
	lda     (sp),y
	clc
	adc     #$03
	sta     ptr1
	tya
	adc     #$40
	sta     ptr1+1
	lda     #$10
L0CC2:	sta     (ptr1),y
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ playTri (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_playTri: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; *((unsigned char*)0x4008) = 0x7f;
;
	lda     #$7F
	sta     $4008
;
; *((unsigned char*)0x400a) = notes[note];
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     _notes,y
	sta     $400A
;
; if(note < 5)   *((unsigned char*)0x400b) = 0x13;
;
	ldy     #$00
	lda     (sp),y
	cmp     #$05
	bcs     L0CC9
	lda     #$13
;
; else if(note < 12)  *((unsigned char*)0x400b) = 0x12;
;
	jmp     L0CC7
L0CC9:	lda     (sp),y
	cmp     #$0C
	bcs     L0CCB
	lda     #$12
;
; else if(note < 24)  *((unsigned char*)0x400b) = 0x11;
;
	jmp     L0CC7
L0CCB:	lda     (sp),y
	cmp     #$18
	bcs     L0CCC
	lda     #$11
;
; else     *((unsigned char*)0x400b) = 0x10;
;
	jmp     L0CC7
L0CCC:	lda     #$10
L0CC7:	sta     $400B
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ playNoise (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_playNoise: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; *((uchar*)0x400c) = 0x0f;
;
	lda     #$0F
	sta     $400C
;
; *((uchar*)0x400e) = note | 0x40;
;
	ldy     #$00
	lda     (sp),y
	ora     #$40
	sta     $400E
;
; *((uchar*)0x400f) = 0xF8;
;
	lda     #$F8
	sta     $400F
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ sneezeSound (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_sneezeSound: near

.segment	"CODE"

;
; *((uchar*)0x400c) = 0x0f;
;
	lda     #$0F
	sta     $400C
;
; *((uchar*)0x400e) = 13 | 0x40;
;
	lda     #$4D
	sta     $400E
;
; *((uchar*)0x400f) = 0xF0;
;
	lda     #$F0
	sta     $400F
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ bossaSong (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_bossaSong: near

.segment	"CODE"

;
; if(currentTick == 12) 
;
	lda     _currentTick
	cmp     #$0C
	beq     L0CE3
;
; }
;
	rts
;
; currentTick = 0;
;
L0CE3:	lda     #$00
	sta     _currentTick
;
; if((currentBar == 0 || currentBar == 1 || currentBar == 3) 
;
	lda     _currentBar
	beq     L0CD6
	lda     _currentBar
	cmp     #$01
	beq     L0CD6
	cmp     #$03
	bne     L0CD9
;
; && currentSemiQ == bossaBassA[bossaBassPos][1])
;
L0CD6:	lda     _currentSemiQ
	jsr     pusha0
	lda     _bossaBassPos
	asl     a
	bcc     L0CD2
	ldx     #$01
	clc
L0CD2:	adc     #<(_bossaBassA)
	sta     ptr1
	txa
	adc     #>(_bossaBassA)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     tosicmp0
	bne     L0CD9
;
; playTri(bossaBassA[bossaBassPos][0]);
;
	ldx     #$00
	lda     _bossaBassPos
	asl     a
	bcc     L0CCE
	inx
L0CCE:	sta     ptr1
	txa
	clc
	adc     #>(_bossaBassA)
	sta     ptr1+1
	ldy     #<(_bossaBassA)
;
; else if(currentBar == 2 && currentSemiQ == bossaBassB[bossaBassPos][1])
;
	jmp     L0CE2
L0CD9:	lda     _currentBar
	cmp     #$02
	bne     L0CDB
	lda     _currentSemiQ
	jsr     pusha0
	lda     _bossaBassPos
	asl     a
	bcc     L0CD3
	ldx     #$01
	clc
L0CD3:	adc     #<(_bossaBassB)
	sta     ptr1
	txa
	adc     #>(_bossaBassB)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     tosicmp0
	bne     L0CDB
;
; playTri(bossaBassB[bossaBassPos][0]);
;
	ldx     #$00
	lda     _bossaBassPos
	asl     a
	bcc     L0CD0
	inx
L0CD0:	sta     ptr1
	txa
	clc
	adc     #>(_bossaBassB)
	sta     ptr1+1
	ldy     #<(_bossaBassB)
L0CE2:	lda     (ptr1),y
	jsr     _playTri
;
; ++bossaBassPos;
;
	inc     _bossaBassPos
;
; if(bossaBassPos == 8) bossaBassPos = 0;
;
	lda     _bossaBassPos
	cmp     #$08
	bne     L0CDB
	lda     #$00
	sta     _bossaBassPos
;
; ++currentSemiQ;
;
L0CDB:	inc     _currentSemiQ
;
; if(currentSemiQ == 16)
;
	lda     _currentSemiQ
	cmp     #$10
	bne     L07B5
;
; currentSemiQ = 0;
;
	lda     #$00
	sta     _currentSemiQ
;
; ++currentBar;
;
	inc     _currentBar
;
; if(currentBar == 4) currentBar = 0;
;
	lda     _currentBar
	cmp     #$04
	bne     L07B5
	lda     #$00
	sta     _currentBar
;
; }
;
L07B5:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ songTest (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_songTest: near

.segment	"CODE"

;
; if(currentTick >= 15)
;
	lda     _currentTick
	cmp     #$0F
	bcc     L07C8
;
; currentTick = 0;
;
	lda     #$00
	sta     _currentTick
;
; ++bassNote;
;
	inc     _bassNote
;
; playSquare(bassLine[bassNote], SQUARE_ONE);
;
	ldy     _bassNote
	lda     _bassLine,y
	jsr     pusha
	lda     #$00
	jsr     _playSquare
;
; if(bassNote > 3) 
;
	lda     _bassNote
	cmp     #$04
	bcc     L0CE4
;
; bassNote = 0;
;
	lda     #$00
	sta     _bassNote
;
; if(bassNote == 1)
;
L0CE4:	lda     _bassNote
	cmp     #$01
;
; sneezeSound();
;
	jeq     _sneezeSound
;
; }
;
L07C8:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; All_Off(); // turn off screen
;
	jsr     _All_Off
;
; Draw_Title();
;
	jsr     _Draw_Title
;
; X1 = 0x80; // starting position
;
	lda     #$80
	sta     _X1
;
; Y1 = 0x70; // middle of screen
;
	lda     #$70
	sta     _Y1
;
; Set_Sprite_Zero();
;
	jsr     _Set_Sprite_Zero
;
; Load_Palette();
;
	jsr     _Load_Palette
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; setupAudio();
;
	jsr     _setupAudio
;
; Wait_Vblank();
;
	jsr     _Wait_Vblank
;
; All_On(); // turn on screen
;
	jsr     _All_On
;
; while (Game_Mode == TITLE_MODE){ // Title Screen
;
	jmp     L0CEC
;
; while (NMI_flag == 0); // wait till v-blank
;
L0CE6:	lda     _NMI_flag
	beq     L0CE6
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; Get_Input();
;
	jsr     _Get_Input
;
; if (((joypad1old & START) == 0) && ((joypad1 & START) != 0))
;
	lda     _joypad1old
	and     #$10
	bne     L0CF9
	lda     _joypad1
	and     #$10
	beq     L0CFB
;
; NMI_flag = 0;
;
	lda     #$00
	sta     _NMI_flag
;
; while (NMI_flag == 0); // wait till v-blank
;
L0CE9:	lda     _NMI_flag
	beq     L0CE9
;
; Game_Mode = RUN_GAME_MODE;
;
	lda     #$01
	sta     _Game_Mode
;
; All_Off(); // turn off screen
;
	jsr     _All_Off
;
; PPU_CTRL = 0x90; // rightward increments to PPU
;
	lda     #$90
	sta     $2000
;
; Load_HUD();
;
	jsr     _Load_HUD
;
; Draw_Background();
;
	jsr     _Draw_Background
;
; X1 = 0x80; // starting position
;
	lda     #$80
	sta     _X1
;
; Y1 = 0x70; // middle of screen
;
	lda     #$70
	sta     _Y1
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; PPU_CTRL = 0x91;
;
	lda     #$91
	sta     $2000
;
; lives = 3;
;
	lda     #$03
	sta     _lives
;
; NMI_flag = 0;
;
L0CF9:	lda     #$00
L0CFB:	sta     _NMI_flag
;
; while (Game_Mode == TITLE_MODE){ // Title Screen
;
L0CEC:	lda     _Game_Mode
	beq     L0CE6
;
; while (Game_Mode == RUN_GAME_MODE)
;
	jmp     L0CF1
;
; while (NMI_flag == 0)
;
L0CED:	lda     _NMI_flag
	beq     L0CED
;
; PPU_ADDRESS = 0x20;
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = 0x49;
;
	lda     #$49
	sta     $2006
;
; PPU_DATA = lives+'0'+32;
;
	lda     _lives
	clc
	adc     #$30
	bcc     L0CE5
	clc
L0CE5:	adc     #$20
	sta     $2007
;
; if (PPU_flag != 0)
;
	lda     _PPU_flag
	beq     L0CEE
;
; Do_Buffer2();
;
	jsr     _Do_Buffer2
;
; PPU_CTRL = 0x94;
;
L0CEE:	lda     #$94
	sta     $2000
;
; SCROLL = 0;
;
	lda     #$00
	sta     $2005
;
; SCROLL = 0; // resetting scroll position, again
;
	sta     $2005
;
; if (PPU_flag2 != 0)
;
	lda     _PPU_flag2
	beq     L0CEF
;
; Do_Buffer3();
;
	jsr     _Do_Buffer3
;
; PPU_CTRL = 0x94;
;
L0CEF:	lda     #$94
	sta     $2000
;
; SCROLL = 0;
;
	lda     #$00
	sta     $2005
;
; SCROLL = 0; // resetting scroll position, again
;
	sta     $2005
;
; Get_Input();
;
	jsr     _Get_Input
;
; PPU_flag = 0;
;
	lda     #$00
	sta     _PPU_flag
;
; PPU_flag2 = 0;        // makes it 'disappear'
;
	sta     _PPU_flag2
;
; Sprite_Zero();
;
	jsr     _Sprite_Zero
;
; SCROLL = Horiz_scroll;
;
	lda     _Horiz_scroll
	sta     $2005
;
; SCROLL = 0; // setting the new scroll position
;
	lda     #$00
	sta     $2005
;
; PPU_CTRL = (0x94 + Nametable);
;
	lda     _Nametable
	clc
	adc     #$94
	sta     $2000
;
; move_logic();
;
	jsr     _move_logic
;
; audioUpdate();
;
	jsr     _audioUpdate
;
; update_Sprites();
;
	jsr     _update_Sprites
;
; RoomPlus = Room; // make a copy of variables, but 20 pixels right
;
	lda     _Room
	sta     _RoomPlus
;
; Nametable_Plus = Nametable;
;
	lda     _Nametable
	sta     _Nametable_Plus
;
; Horiz_scroll_Plus = Horiz_scroll + 0x20;
;
	lda     _Horiz_scroll
	clc
	adc     #$20
	sta     _Horiz_scroll_Plus
;
; if (Horiz_scroll_Plus < 0x20)
;
	cmp     #$20
	bcs     L0CF0
;
; ++RoomPlus;
;
	inc     _RoomPlus
;
; ++Nametable_Plus;
;
	inc     _Nametable_Plus
;
; RoomPlus &= 3;
;
	lda     _RoomPlus
	and     #$03
	sta     _RoomPlus
;
; Nametable_Plus &= 1;
;
	lda     _Nametable_Plus
	and     #$01
	sta     _Nametable_Plus
;
; if ((Horiz_scroll_Plus & 0x1e) == 0)
;
L0CF0:	lda     _Horiz_scroll_Plus
	and     #$1E
	bne     L08BF
;
; New_Room(); // 6245 cycles
;
	jsr     _New_Room
;
; Should_We_Buffer(); // 4422 cycles
;
L08BF:	jsr     _Should_We_Buffer
;
; NMI_flag = 0;
;
	lda     #$00
	sta     _NMI_flag
;
; while (Game_Mode == RUN_GAME_MODE)
;
L0CF1:	lda     _Game_Mode
	cmp     #$01
	jeq     L0CED
;
; while (Game_Mode == GAME_OVER_MODE){ // Title Screen
;
	jmp     L0CF8
;
; while (NMI_flag == 0); // wait till v-blank
;
L0CF2:	lda     _NMI_flag
	beq     L0CF2
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; Get_Input();
;
	jsr     _Get_Input
;
; if (((joypad1old & START) == 0) && ((joypad1 & START) != 0))
;
	lda     _joypad1old
	and     #$10
	bne     L0CFA
	lda     _joypad1
	and     #$10
	beq     L0CFC
;
; NMI_flag = 0;
;
	lda     #$00
	sta     _NMI_flag
;
; while (NMI_flag == 0); // wait till v-blank
;
L0CF5:	lda     _NMI_flag
	beq     L0CF5
;
; Game_Mode = TITLE_MODE;
;
	lda     #$00
	sta     _Game_Mode
;
; All_Off(); // turn off screen
;
	jsr     _All_Off
;
; Draw_Title();
;
	jsr     _Draw_Title
;
; X1 = 0x80; // starting position
;
	lda     #$80
	sta     _X1
;
; Y1 = 0x70; // middle of screen
;
	lda     #$70
	sta     _Y1
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; Wait_Vblank();
;
	jsr     _Wait_Vblank
;
; PPU_CTRL = 0x91;
;
	lda     #$91
	sta     $2000
;
; lives = 3;
;
	lda     #$03
	sta     _lives
;
; NMI_flag = 0;
;
L0CFA:	lda     #$00
L0CFC:	sta     _NMI_flag
;
; while (Game_Mode == GAME_OVER_MODE){ // Title Screen
;
L0CF8:	lda     _Game_Mode
	cmp     #$03
	beq     L0CF2
;
; while (1)
;
	jmp     L0CEC

.endproc

